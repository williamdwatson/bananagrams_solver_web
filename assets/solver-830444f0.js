var j=Object.defineProperty;var H=(V,P,w)=>P in V?j(V,P,{enumerable:!0,configurable:!0,writable:!0,value:w}):V[P]=w;var F=(V,P,w)=>(H(V,typeof P!="symbol"?P+"":P,w),w);(function(){"use strict";const w="ABCDEFGHIJKLMNOPQRSTUVWXYZ";function R(e){let t=e.length;return e.forEach(i=>{let l=(i>>16^i)*73244475,c=(l>>16^l)*73244475,m=c>>16^c;t^=m+2654435769+(t<<6)+(t>>2)}),t}function C(e,t){if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0}class O{constructor(){F(this,"arr");this.arr=new Uint8Array(144*144),this.arr.fill(30)}get_val(t,i){return this.arr[t*144+i]}set_val(t,i,l){this.arr[t*144+i]=l}}function v(e,t){if(e==null||t==null)return new Set;{const i=[];for(let l=0;l<Math.min(e.length,t.length);l++)if(C(e[l][0],t[l][0])&&e[l][1][0]===t[l][1][0]&&e[l][1][1]===t[l][1][1]&&e[l][1][2]===t[l][1][2]){const c=e[l][0].length,m=e[l][1][0],h=e[l][1][1];if(e[l][1][2]==="horizontal")for(let r=0;r<c;r++)i.push([m,h+r]);else for(let r=0;r<c;r++)i.push([m+r,h])}return new Set(i.map(R))}}function Y(e,t,i,l,c,m){const h=[];for(let r=l;r<c+1;r++){const a=[];for(let n=t;n<i+1;n++)if(e.get_val(r,n)==30)a.push(" ");else{const s=String.fromCharCode(e.get_val(r,n)+65);m.has(R([r,n]))?a.push(s+"*"):a.push(s)}h.push(a)}return h}function I(e,t){const i=new Uint8Array(t.length);for(let l=0;l<t.length;l++)i[l]=t[l];for(let l=0;l<e.length;l++){if(i[e[l]]===0)return!1;i[e[l]]-=1}return!0}function x(e,t,i){const l=new Int8Array(e);let c=!1;for(const m of t){const h=l[m];if(h===0&&!i.has(m))return!1;if(h===0&&c)return!1;h===0&&(c=!0),l[m]-=1}return!0}function B(e,t,i,l,c,m,h,r,a){let n=[];for(let s=t;s<i+1;s++)if(e.get_val(m,s)!=30)n.push(e.get_val(m,s));else{if(n.length>1&&!a.has(R(n)))return!1;if(n=[],s>r)break}if(n.length>1&&!a.has(R(n)))return!1;for(let s=h;s<r+1;s++){n=[];for(let o=l;o<c+1;o++)if(e.get_val(o,s)!=30)n.push(e.get_val(o,s));else{if(n.length>1&&!a.has(R(n)))return!1;if(n=[],o>m)break}if(n.length>1&&!a.has(R(n)))return!1}return!0}function Z(e,t,i,l,c,m,h,r,a){let n=[];for(let s=l;s<c+1;s++)if(e.get_val(s,r)!=30)n.push(e.get_val(s,r));else{if(n.length>1&&!a.has(R(n)))return!1;if(n=[],s>h)break}if(n.length>1&&!a.has(R(n)))return!1;for(let s=m;s<h+1;s++){n=[];for(let o=t;o<i+1;o++)if(e.get_val(s,o)!=30)n.push(e.get_val(s,o));else{if(n.length>1&&!a.has(R(n)))return!1;if(n=[],o>r)break}if(n.length>1&&!a.has(R(n)))return!1}return!0}function D(e,t,i,l,c,m){const h=[];if(c==="horizontal"){if(i+e.length>=144)return null;const r=Uint8Array.from(m);let a=i!=0&&l.get_val(t,i-1)!=30||144-i<=e.length&&l.get_val(t,i+e.length)!=30;if(!a){for(let n=i;n<i+e.length;n++)if(t<144-1&&l.get_val(t+1,n)!=30||t>0&&l.get_val(t-1,n)!=30){a=!0;break}}if(a){let n=!0;for(let s=0;s<e.length;s++)if(l.get_val(t,i+s)==30){if(l.set_val(t,i+s,e[s]),h.push([t,i+s]),n=!1,r[e[s]]===0)return[!1,h,r,"Overused"];r[e[s]]-=1}else if(l.get_val(t,i+s)!==e[s])return[!1,h,r,"Remaining"];return r.every(s=>s===0)&&!n?[!0,h,r,"Finished"]:[!n,h,r,"Remaining"]}else return[!1,h,r,"Remaining"]}else{if(t+e.length>=144)return null;const r=Uint8Array.from(m);let a=t!=0&&l.get_val(t-1,i)!=30||144-t<=e.length&&l.get_val(t+e.length,i)!=30;if(!a){for(let n=t;n<t+e.length;n++)if(i<144-1&&l.get_val(n,i+1)!=30||i>0&&l.get_val(n,i-1)!=30){a=!0;break}}if(a){let n=!0;for(let s=0;s<e.length;s++)if(l.get_val(t+s,i)==30){if(l.set_val(t+s,i,e[s]),h.push([t+s,i]),n=!1,r[e[s]]===0)return[!1,h,r,"Overused"];r[e[s]]-=1}else if(l.get_val(t+s,i)!==e[s])return[!1,h,r,"Remaining"];return r.every(s=>s==0)&&!n?[!0,h,r,"Finished"]:[!n,h,r,"Remaining"]}else return[!1,h,r,"Remaining"]}}function S(e,t){for(const i of t)e.set_val(i[0],i[1],30)}function T(e,t,i,l,c,m,h,r,a,n,s){if(a+1<s.length){const o=s[a+1][0],u=s[a+1][1][0],g=s[a+1][1][1],f=D(o,u,g,e,s[a+1][1][2],r);if(f==null)return f;if(f[0])if(s[a+1][1][2]==="horizontal"){const _=Math.min(t,g),E=Math.max(i,g+o.length),M=Math.min(l,u),A=Math.max(c,u);if(B(e,_,E,M,A,u,g,g+o.length-1,h)){if(n.push([o,[f[1][0][0],f[1][0][1],"horizontal"]]),f[3]==="Finished")return[!0,_,E,M,A];if(f[3]==="Remaining"){const U=T(e,_,E,M,A,m,h,f[2],a+1,n,s);if(U==null)return null;if(U[0])return U;n.pop(),S(e,f[1])}}else S(e,f[1])}else{const _=Math.min(t,g),E=Math.max(i,g),M=Math.min(l,u),A=Math.max(c,u+o.length);if(Z(e,_,E,M,A,u,u+o.length-1,g,h)){if(n.push([o,[f[1][0][0],f[1][0][1],"vertical"]]),f[3]==="Finished")return[!0,_,E,M,A];if(f[3]==="Remaining"){const U=T(e,_,E,M,A,m,h,f[2],a+1,n,s);if(U==null)return null;if(U[0])return U;n.pop(),S(e,f[1])}}else S(e,f[1])}else S(e,f[1]);return[!1,t,i,l,c]}else if(a%2==1){for(const o of m)for(let u=l-1;u<c+2;u++)for(let g=t-o.length;g<i+2;g++){const f=D(o,u,g,e,"horizontal",r);if(f==null)return null;if(f[0]){const _=Math.min(t,g),E=Math.max(i,g+o.length),M=Math.min(l,u),A=Math.max(c,u);if(B(e,_,E,M,A,u,g,g+o.length-1,h)){if(n.push([o,[f[1][0][0],f[1][0][1],"horizontal"]]),f[3]==="Finished")return[!0,_,E,M,A];if(f[3]==="Remaining"){const U=T(e,_,E,M,A,m,h,f[2],a+1,n,s);if(U==null)return null;if(U[0])return U;n.pop(),S(e,f[1])}}else S(e,f[1])}else S(e,f[1])}for(const o of m)for(let u=t-1;u<i+2;u++)for(let g=l-o.length;g<c+2;g++){const f=D(o,g,u,e,"vertical",r);if(f==null)return null;if(f[0]){const _=Math.min(t,u),E=Math.max(i,u),M=Math.min(l,g),A=Math.max(c,g+o.length);if(Z(e,_,E,M,A,g,g+o.length-1,u,h)){if(n.push([o,[f[1][0][0],f[1][0][1],"vertical"]]),f[3]==="Finished")return[!0,_,E,M,A];if(f[3]==="Remaining"){const U=T(e,_,E,M,A,m,h,f[2],a+1,n,s);if(U==null)return null;if(U[0])return U;n.pop(),S(e,f[1])}}else S(e,f[1])}else S(e,f[1])}return[!1,t,i,l,c]}else{for(const o of m)for(let u=t-1;u<i+2;u++)for(let g=l-o.length;g<c+2;g++){const f=D(o,g,u,e,"vertical",r);if(f==null)return null;if(f[0]){const _=Math.min(t,u),E=Math.max(i,u),M=Math.min(l,g),A=Math.max(c,g+o.length);if(Z(e,_,E,M,A,g,g+o.length-1,u,h)){if(n.push([o,[f[1][0][0],f[1][0][1],"vertical"]]),f[3]==="Finished")return[!0,_,E,M,A];if(f[3]==="Remaining"){const U=T(e,_,E,M,A,m,h,f[2],a+1,n,s);if(U==null)return null;if(U[0])return U;n.pop(),S(e,f[1])}}else S(e,f[1])}else S(e,f[1])}for(const o of m)for(let u=l-1;u<c+2;u++)for(let g=t-o.length;g<i+2;g++){const f=D(o,u,g,e,"horizontal",r);if(f==null)return null;if(f[0]){const _=Math.min(t,g),E=Math.max(i,g+o.length),M=Math.min(l,u),A=Math.max(c,u);if(B(e,_,E,M,A,u,g,g+o.length-1,h)){if(n.push([o,[f[1][0][0],f[1][0][1],"horizontal"]]),f[3]==="Finished")return[!0,_,E,M,A];if(f[3]==="Remaining"){const U=T(e,_,E,M,A,m,h,f[2],a+1,n,s);if(U==null)return null;if(U[0])return U;n.pop(),S(e,f[1])}}else S(e,f[1])}else S(e,f[1])}return[!1,t,i,l,c]}}function G(e,t,i,l,c,m,h){for(let r=l-1;r<c+2;r++)for(let a=t-1;a<i+2;a++)if(r<144&&a<144&&e.get_val(r,a)==30&&(a>0&&e.get_val(r,a-1)!=30||a<144-1&&e.get_val(r,a+1)!=30||r>0&&e.get_val(r-1,a)!=30||r<144-1&&e.get_val(r+1,a)!=30)){e.set_val(r,a,m);const n=Math.min(t,a),s=Math.max(i,a),o=Math.min(l,r),u=Math.max(c,r);if(B(e,n,s,o,u,r,a,a,h))return[r,a,n,s,o,u];e.set_val(r,a,30)}return null}function k(e,t,i,l){const c=new O,m=e[0][1][0],h=e[0][1][1],r=e[0][0],a=Uint8Array.from(l),n=new Set;for(let _=0;_<r.length;_++)c.set_val(m,h+_,r[_]),a[r[_]]-=1,n.add(r[_]);const s=h,o=m,u=h+(r.length-1),g=m,f=[];if(f.push([r,[m,h,"horizontal"]]),a.every(_=>_==0))return[c,f,s,u,o,g];{const _=t.filter(M=>x(a,M,n)),E=T(c,s,u,o,g,_,i,a,0,f,e);return E==null?null:E[0]?[c,f,E[1],E[2],E[3],E[4]]:null}}function N(e,t){var m,h;const i=new Date,l=new Uint8Array(26);for(const r of w){const a=e.get(r);if(a!=null){if(a<0)return"Number of letter "+r+" is "+a+", but must be greater than or equal to 0!";l[r.charCodeAt(0)-65]=a}else return"Missing letter: "+r}if(t.last_game!=null){let r="Same",a=30;for(let n=0;n<26;n++)if(l[n]<t.last_game.letters[n]){r="SomeLess";break}else l[n]>t.last_game.letters[n]&&(a!=30||l[n]-t.last_game.letters[n]!=1)?r="GreaterByMoreThanOne":l[n]>t.last_game.letters[n]&&(r="GreaterByOne",a=n);if(r==="Same"){const n=new O;return n.arr=t.last_game.board,{board:Y(n,t.last_game.min_col,t.last_game.max_col,t.last_game.min_row,t.last_game.max_row,new Set),elapsed:new Date().getMilliseconds()-i.getMilliseconds(),state:{board:t.last_game.board,min_col:t.last_game.min_col,max_col:t.last_game.max_col,min_row:t.last_game.min_row,max_row:t.last_game.max_row,letters:t.last_game.letters}}}else if(r==="GreaterByOne"){const n=t.all_words_short.filter(g=>I(g,l)),s=new Set(n.map(R)),o=new O;o.arr=t.last_game.board;const u=G(o,t.last_game.min_col,t.last_game.max_col,t.last_game.min_row,t.last_game.max_row,a,s);if(u==null){const g=k(t.last_game.play_sequence,n,s,l);if(g!=null){const f=v(t.last_game.play_sequence,g[1]);return{board:Y(g[0],g[2],g[3],g[4],g[5],f),elapsed:new Date().getMilliseconds()-i.getMilliseconds(),state:{board:g[0].arr,min_col:g[2],max_col:g[3],min_row:g[4],max_row:g[5],letters:l,play_sequence:g[1]}}}}else{const g=[...t.last_game.play_sequence],f=new Uint8Array(1);f[0]=a,g.push([f,[u[0],u[1],"horizontal"]]);const _=v(t.last_game.play_sequence,g);return{board:Y(o,u[2],u[3],u[4],u[5],_),elapsed:new Date().getMilliseconds()-i.getMilliseconds(),state:{board:o.arr,min_col:u[2],max_col:u[3],min_row:u[4],max_row:u[5],letters:l,play_sequence:g}}}}else if(r==="GreaterByMoreThanOne"){const n=t.all_words_short.filter(u=>I(u,l)),s=new Set(n.map(R)),o=k(t.last_game.play_sequence,n,s,l);if(o!=null){const u=v(t.last_game.play_sequence,o[1]);return{board:Y(o[0],o[2],o[3],o[4],o[5],u),elapsed:new Date().getMilliseconds()-i.getMilliseconds(),state:{board:o[0].arr,min_col:o[2],max_col:o[3],min_row:o[4],max_row:o[5],letters:l,play_sequence:o[1]}}}}}let c=t.all_words_short.filter(r=>I(r,l));if(c.length==0)return"No valid words can be formed from the current letters - dump and try again!";for(const r of c){const a=new O,n=Math.round(144/2-r.length/2),s=Math.round(144/2),o=Uint8Array.from(l);for(let M=0;M<r.length;M++)a.set_val(s,n+M,r[M]),o[r[M]]-=1;const u=n,g=s,f=n+(r.length-1),_=s,E=[];if(E.push([r,[s,n,"horizontal"]]),o.every(M=>M==0)){const M=v((m=t.last_game)==null?void 0:m.play_sequence,E);return{board:Y(a,u,f,g,_,M),elapsed:new Date().getMilliseconds()-i.getMilliseconds(),state:{board:a.arr,min_col:u,max_col:f,min_row:g,max_row:_,letters:l,play_sequence:E}}}else{const M=new Set(l),A=c.filter(z=>x(o,z,M)),U=new Set(c.map(R)),L=T(a,u,f,g,_,A,U,o,0,E,[]);if(L==null||!L[0])return"No valid words can be formed from the current letters - dump and try again!";{const z=v((h=t.last_game)==null?void 0:h.play_sequence,E);return{board:Y(a,L[1],L[2],L[3],L[4],z),elapsed:new Date().getMilliseconds()-i.getMilliseconds(),state:{board:a.arr,min_col:L[1],max_col:L[2],min_row:L[3],max_row:L[4],letters:l,play_sequence:E}}}}}}self.addEventListener("message",e=>{const t=N(e.data.letters,e.data.gameState);self.postMessage(t)},!1)})();
